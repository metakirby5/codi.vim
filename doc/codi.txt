                                                                        *codi*
             .------------.~
             |    .---.   |    .---.     .----.     ---.---~
             |   /        |   /     \    |     \       |~
             |  (         |  (       )   |      |      |~
             |   \        |   \     /    |     /       |~
             |    '---'   |    '---'     '----'     ---'---~
             '------------'~
              The interactive scratchpad for hackers.~

Author:   Ethan Chan <metakirby5@gmail.com>
License:  MIT
Repo:     https://github.com/metakirby5/codi.vim

==============================================================================
TABLE OF CONTENTS                                              *codi-contents*

INTRODUCTION...............................................|codi-introduction|
    SYNCHRONOUS VS ASYNCHRONOUS.................|codi-introduction-sync-diffs|
    WARNINGS......................................|codi-introduction-warnings|
    DEPENDENCIES...........................................|codi-dependencies|
USAGE.............................................................|codi-usage|
    :Codi {filetype}...................................................|:Codi|
    :Codi!............................................................|:Codi!|
    :Codi!! {filetype}...............................................|:Codi!!|
    :CodiUpdate..................................................|:CodiUpdate|
    SHELL WRAPPER.........................................|codi-usage-wrapper|
CONFIGURATION.............................................|codi-configuration|
    g:codi#interpreters..................................|g:codi#interpreters|
    g:codi#aliases............................................|g:codi#aliases|
    g:codi#autocmd............................................|g:codi#autocmd|
    g:codi#width................................................|g:codi#width|
    g:codi#rightsplit......................................|g:codi#rightsplit|
    g:codi#rightalign......................................|g:codi#rightalign|
    g:codi#autoclose........................................|g:codi#autoclose|
    g:codi#raw....................................................|g:codi#raw|
    g:codi#sync..................................................|g:codi#sync|
AUTOCOMMANDS...............................................|codi-autocommands|
    CodiEnterPre................................................|CodiEnterPre|
    CodiEnterPost..............................................|CodiEnterPost|
    CodiUpdatePre..............................................|CodiUpdatePre|
    CodiUpdatePost............................................|CodiUpdatePost|
    CodiLeavePre................................................|CodiLeavePre|
    CodiLeavePost..............................................|CodiLeavePost|
INTERPRETERS...............................................|codi-interpreters|
    DEFAULT INTERPRETERS..........................|codi-interpreters-defaults|
    OUTPUT SPECIFICATION.......................|codi-interpreters-output-spec|
    EXAMPLE INTERPRETER CONFIGURATION..............|codi-interpreters-example|
    POSSIBLE ATTRIBUTES.........................|codi-interpreters-attributes|
        bin............................................|codi-interpreters-bin|
        prompt......................................|codi-interpreters-prompt|
        preprocess..............................|codi-interpreters-preprocess|
        rephrase..................................|codi-interpreters-rephrase|

==============================================================================
INTRODUCTION                                               *codi-introduction*

Codi is an interactive scratchpad for hackers, with a similar interface to
Numi (https://numi.io). It opens a pane synchronized to your main buffer which
displays the results of evaluating each line as you type (if Vim has |+job|
and |+channel|, asynchronously). It's extensible to nearly any language that
provides a REPL (interactive interpreter)!

See |codi-interpreters-defaults| for languages with built-in support.

Watch a screencast at https://ptpb.pw/t/~codi!

SYNCHRONOUS VS ASYNCHRONOUS                     *codi-introduction-sync-diffs*

     +---------------+-----------------------------------+-------------+
     | Asynchronous? | Default autocommands for updates  | Blocking?   |
     +---------------+-----------------------------------+-------------+
     | yes           | |TextChanged|, |TextChangedI|         | no          |
     | no            | |CursorHold|, |CursorHoldI|           | yes         |
     +---------------+-----------------------------------+-------------+

WARNINGS                                          *codi-introduction-warnings*

Be EXTREMELY careful with lazily evaluated languages and infinite loops. I
cannot stress this enough: the moment you type an infinite list, your CPU
usage will probably skyrocket. If you are running Codi without asynchronous
support, Vim will also freeze.

For example, as cool as this is, NEVER attempt the below in Codi with Haskell:
>
             let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
             f !! 5
<
Even if you only intend to extract the 5th element of f, unless you are clever
about how you write it, the second line will be just "f" at some point. This
leads to evaluating the infinite list, which you might not notice for a few
seconds, but will definitely stress out your computer if you leave it going
for much longer.

Should this happen to you, find and kill the interpreter. Seriously!

Also, Codi will very occasionally leave interpreters running in the background
which need to be killed. This has only been observed with Haskell (ghci), so
if your fans spin up, you may need to investigate.

DEPENDENCIES                                               *codi-dependencies*

Windows is currently not supported, but check back soon!
https://github.com/metakirby5/codi.vim/issues/14

- OS X or Linux (Windows support coming soon!)
  https://github.com/metakirby5/codi.vim/issues/14
- Vim 7.4 (with |+job| and |+channel| for asynchronous evaluation)
- "uname"
- "script" (BSD or Linux, manpage should say at least 2013)

Each interpreter also depends on its bin; see |codi-interpreters-bin|. These
are loaded on-demand. For example, if you only want to use the Python Codi
interpreter, you will not need ghci.

See |codi-interpreters-defaults| for default interpreter dependencies.

==============================================================================
USAGE                                                             *codi-usage*

                                                                       *:Codi*
:Codi {filetype}
             Activates Codi for the current buffer, using the interpreter
             defined for {filetype}. If {filetype} is not specified, the
             buffer's 'filetype' is used instead.

                                                                      *:Codi!*
:Codi!
             Deactivates Codi for the current buffer.

                                                                     *:Codi!!*
:Codi!! {filetype}
             Toggles Codi for the current buffer.

                                                                 *:CodiUpdate*
:CodiUpdate
             Manually triggers a Codi update. Useful in conjunction with the
             "None" setting for |g:codi#autocmd|.

SHELL WRAPPER                                             *codi-usage-wrapper*

             A nice way to use Codi is through a shell wrapper that you can
             stick in your ~/.bashrc:
>
             # Codi
             # Usage: codi [filetype] [filename]
             codi() {
               vim "$2" -c \
                 "let g:startify_disable_at_vimenter = 1 |\
                 set bt=nofile ls=0 noru nonu nornu |\
                 hi ColorColumn ctermbg=NONE |\
                 hi VertSplit ctermbg=NONE |\
                 hi NonText ctermfg=0 |\
                 Codi ${1:-python}"
             }
<
==============================================================================
CONFIGURATION                                             *codi-configuration*

                                                         *g:codi#interpreters*
g:codi#interpreters
             A dictionary of user-defined interpreters.
             See |codi-interpreters| for the format specification.

             This will not erase the internal default interpreters.
>
             let g:codi#interpreters = {
                   \ 'python': {
                       \ 'bin': 'python',
                       \ 'prompt': '^\(>>>\|\.\.\.\) ',
                       \ },
                   \ }
<
             The interpreter dictionary is deeply updated, so if all you want
             to do is change the Haskell prompt to "> ", use the following:
>
             let g:codi#interpreters = {
                   \ 'haskell': {
                       \ 'prompt': '^> ',
                       \ },
                   \ }
<
             You may also set any of the |per-interpreter| options here. For
             example, if you want to left-align all JavaScript Codi instances,
             but keep right-align as the default:
>
             let g:codi#interpreters = {
                   \ 'javascript': {
                       \ 'rightalign': 0,
                       \ },
                   \ }
<
             Default value is {}.

                                                              *g:codi#aliases*
g:codi#aliases
             A dictionary of user-defined interpreter filetype aliases.
             This allows you to use an interpreter for more than one
             filetype. For example, you can alias "javascript.jsx" to
             "javascript" so the JavaScript interpreter (node) can be used
             for the "javascript.jsx" filetype.

             This will not erase the internal default aliases.
>
             let g:codi#aliases = {
                   \ 'javascript.jsx': 'javascript',
                   \ }
<
             Default value is {}.

The below options can also be set on a *per-interpreter* basis via
|g:codi#interpreters|.

                                                             *g:codi#autocmd*
g:codi#autocmd
             What |autocommand|s trigger updates. Possible values:
             |TextChanged|, |CursorHold|, |InsertLeave|, None.

             These will also register the insert mode variants.
             "None" will make no autocommand trigger updates; use this if you
             only want updates to be manually triggered on `:CodiUpdate`.

             Default value is 'TextChanged' for async, 'CursorHold' for sync.

                                                                *g:codi#width*
g:codi#width
             The width of the Codi split.

             Default value is 40.

                                                           *g:codi#rightsplit*
g:codi#rightsplit
             Whether or not to spawn Codi on the right side of the current
             buffer. If 0, Codi spawns on the left.

             Default value is 1.

                                                           *g:codi#rightalign*
g:codi#rightalign
             Whether or not to right-align the Codi buffer. If 0, the Codi
             buffer is left-aligned.

             Default value is 1.

                                                            *g:codi#autoclose*
g:codi#autoclose
             Whether or not to close Codi when the associated buffer is
             closed.

             Default value is 1.

                                                                  *g:codi#raw*
g:codi#raw
             Whether or not to display interpreter results without
             formatting each expression to align with the line numbers.
             Useful if you are debugging a |codi-interpreters-preprocess|.

             Default value is 0.

                                                                 *g:codi#sync*
g:codi#sync
             Whether or not force synchronous execution.
             No reason to touch this unless you want to compare async to sync.

             Default value is 0.

==============================================================================
AUTOCOMMANDS                                               *codi-autocommands*

                                                                *CodiEnterPre*
CodiEnterPre
             Triggered before a Codi pane enters.

                                                               *CodiEnterPost*
CodiEnterPost
             Triggered after a Codi pane enters.

                                                               *CodiUpdatePre*
CodiUpdatePre
             Triggered before a Codi pane updates.

                                                              *CodiUpdatePost*
CodiUpdatePost
             Triggered after a Codi pane updates.

                                                                *CodiLeavePre*
CodiLeavePre
             Triggered before a Codi pane leaves.

                                                               *CodiLeavePost*
CodiLeavePost
             Triggered after a Codi pane leaves.

==============================================================================
INTERPRETERS                                               *codi-interpreters*

Codi relies on interpreter configurations to understand how to evaluate your
buffer's contents. A number of default interpreters are bundled in, but you
can easily create your own configurations to add support for more filetypes.

If you add support for a new language, please consider sending in a pull
request at https://github.com/metakirby5/codi.vim/pulls!

DEFAULT INTERPRETERS                              *codi-interpreters-defaults*

Codi currently has default support for the following filetypes:

          +------------+--------+----------------------------------+
          | Filetype   | bin    | Notes                            |
          +------------+--------+----------------------------------+
          | python     | python | Cannot leave empty lines in defs |
          | javascript | node   | "var" and "let" show undefined   |
          | haskell    | ghci   | Language pragmas don't work      |
          | ruby       | irb    |                                  |
          | ocaml      | ocaml  | Must end every statement with ;; |
          +------------+--------+----------------------------------+

Note that Codi is not meant to be a replacement for actually running your
program; it supports nothing more than what the underlying bin supports. This
is why Haskell language pragmas don't work and OCaml statements must end with
;;. Also, in most whitespace-sensitive languages, an empty line represents
the end of a definition, so the below Python class will not work in Codi:
>
             class Test(object):
                 def __init__(self):
                     pass

                 def oops_theres_an_empty_line_above_this(self):
                     return 1
<

OUTPUT SPECIFICATION                           *codi-interpreters-output-spec*

To ensure evaluated lines align with the corresponding buffer's lines, the
output prior to formatting (as if you had enabled |g:codi#raw|) must follow
this spec:
>
             [any number of lines]
             [first prompt][any text]
             [any number of lines]
             [result associated with prompt, no leading whitespace]
             [any number of lines with leading whitespace]
             [next prompt][any text]
             ...
<
So, the following would be valid, assuming the prompt regex is "^> ":
>
             LANGUAGE INTERPRETER v1.0              | ignored
             > 1 + 1                                | prompt 1
             2                                      | result for prompt 1
             > make_stacktrace()                    | prompt 2
             A BAD ERROR                            | result for prompt 2
               stacktrace line 1                    | ignored
               stacktrace line 2                    | ignored
               stacktrace line 3                    | ignored
             > function_that_prints_and_returns_1() | prompt 3
             I printed something!                   | ignored
             1                                      | result for prompt 3
             > and so on...                         | prompt 4
<
However, be careful of the following cases:
>
             > 1 + 1      | prompt 1
              2           | IGNORED (leading whitespace)
             > return_1() | prompt 2
             1            | IGNORED (next line has no leading whitespace)
             Returned 1.  | result for prompt 2
<
If your output does not follow spec, you MUST implement
|codi-interpreters-preprocess|.
The easiest way to check is to enable |g:codi#raw|.

EXAMPLE INTERPRETER CONFIGURATION                  *codi-interpreters-example*

A full interpreter configuration for JavaScript can be found below. (Note that
in Vimscript, you still need to add forward slashes for continuing newlines.)
>
             'javascript': {
                 'bin': 'node',
                 'prompt': '^\(>\|\.\.\.\+\) ',
                 'preprocess': function('s:pp_js'),
                 'rephrase': function('s:rp_js'),
             }
<
POSSIBLE ATTRIBUTES                             *codi-interpreters-attributes*

Interpreter configurations have an number of attributes, but only a few of
them are required. However, you may need to use the optional attributes
to get your interpreter to successfully work.

                                                       *codi-interpreters-bin*
bin (REQUIRED)
             Defines the command to use for the REPL backing the interpreter.
             For example, it would be "python" for Python, "node" for
             JavaScript, and "irb" for Ruby. Can either be a string or an
             array of strings, if the command require arguments. One possible
             array, for example, is ["irb", "--prompt", "default"]. Array
             arguments will not be automatically quoted.

                                                    *codi-interpreters-prompt*
prompt (REQUIRED)
             A vim-style regex pattern that exactly matches the prompt of
             bin. This will be used to correctly line up the output of bin
             with your buffer.

             In the JavaScript example, we set prompt to match
             ">", "...", and any amount of dots greater than that to
             accommodate further nesting levels.

                                                *codi-interpreters-preprocess*
preprocess (OPTIONAL)
             A function to adjust the output of bin after running the buffer
             contents. Useful if control characters need to be filtered out,
             or if the output is non-standard in any way. After preprocess,
             the output should conform to |codi-interpreters-output-spec|.
             That way, output result lines can be successfully lined up with
             the corresponding lines.

             The function should take a single string argument that is a line
             of output, and return a single string that is the adjusted line 
             of output.

             When creating your own preprocess, it is useful to enable
             |g:codi#raw| to see what the output initially looks like, and
             what your preprocess function does to the output.

             In the JavaScript example, "node" has a tendency to print out
             escape codes with a pattern of <esc> followed by some characters,
             so we strip those with the following function:
>
             function! s:pp_js(line)
               " Strip escape codes
               return substitute(a:line, "\<esc>".'\[\d\(\a\|\dm\)', '', 'g')
             endfunction
<
             Notice that in the example, preprocess is configured as
             `function('s:pp_js')`. In case you are unfamiliar with Vimscript,
             this is the construct that is normally used to pass functions as
             data.

             Default value is the identity function.

                                                  *codi-interpreters-rephrase*
rephrase (OPTIONAL)
             A function to adjust the contents of the current buffer to,
             before it is sent to bin. Useful if you need to modify certain
             lines to get them to evaluate to your liking.

             The function should take a single string argument that is the
             contents of the current buffer, and return a single string that
             is the adjusted contents to send to bin. Note: unlike preprocess,
             which operates per-line, rephrase operates on the entire buffer.

             This attribute is actually not recommended, since it is very
             difficult to achieve desired goals without unforeseen
             side-effects. None of the default interpreters actually use
             rephrase. However, for example, if you REALLY want
             "let var x = 5" to show "5" instead of "undefined", this is the
             way to do it.

             The configuration process is similar to preprocess, so just look
             at |codi-interpreters-preprocess| if you're unsure how to start.

             Default value is the identity function.

vim:ft=help:tw=78:sw=13:norl:
